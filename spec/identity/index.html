<!doctype html><html lang="en">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport">
  <title>Web Identity and Discovery</title>
  <meta content="w3c/ED" name="w3c-status">
  <link href="https://www.w3.org/StyleSheets/TR/2021/W3C-ED" rel="stylesheet">
  <meta content="Bikeshed version d5d58a306, updated Fri Jan 26 16:12:28 2024 -0800" name="generator">
  <link href="http://www.w3.org/TR/webid/" rel="canonical">
  <link href="https://www.w3.org/2008/site/images/favicon.ico" rel="icon">
  <meta content="53e1b86dbfa86f3ba3264112c79df37cc58ded69" name="revision">
<style>

    /* Reset base counters and additional ones */
    body { counter-reset: example note issue assertion advisement figure !important; }

    /* Configure increments for additional counters */
    .note { counter-increment: note; }
    .assertion { counter-increment: assertion; }
    .advisement { counter-increment: advisement; }

    /* Configure display of additional counters */
    .note:not(.no-marker)::before { content: "Note " counter(note); }
    .assertion:not(.no-marker)::before { content: "Assertion" counter(assertion); }
    .advisement:not(.no-marker)::before { content: "Advisement" counter(advisement); }

    /* Reduce font size of boxes and preformatted blocks */
    .note,
    .issue,
    .example,
    .assertion,
    .advisement { font-size: .9em; }
    pre { font-size: .8em; }

    /* Style prefix tables */
    .prefixes {
      text-align: left;
      border-collapse: collapse;
    }
    .prefixes th, .prefixes td {
      padding: 5px;
      border: 1px solid black;
    }

    /* Style RFC2119 conformance terms */
    em.rfc2119 {
      text-transform: lowercase;
      font-variant: small-caps;
      font-style: normal;
      font-size: 1.1em;
      color: darkred;
    }

    /* Style <code> as in old WebID drafts */
    code {
      color: orangered;
      font-size: .8em;
    }

    /* Resize the full-width diagram */
    .full-width {
      width: 100%;
    }

    /* Some temporary style to render without toc */
    body { 
      padding-left: 24px !important ;
      margin: 0 50px;
      width: 85% !important;
      max-width: 85% !important;
    }

</style>
<style>/* Boilerplate: style-autolinks */
.css.css, .property.property, .descriptor.descriptor {
    color: var(--a-normal-text);
    font-size: inherit;
    font-family: inherit;
}
.css::before, .property::before, .descriptor::before {
    content: "‘";
}
.css::after, .property::after, .descriptor::after {
    content: "’";
}
.property, .descriptor {
    /* Don't wrap property and descriptor names */
    white-space: nowrap;
}
.type { /* CSS value <type> */
    font-style: italic;
}
pre .property::before, pre .property::after {
    content: "";
}
[data-link-type="property"]::before,
[data-link-type="propdesc"]::before,
[data-link-type="descriptor"]::before,
[data-link-type="value"]::before,
[data-link-type="function"]::before,
[data-link-type="at-rule"]::before,
[data-link-type="selector"]::before,
[data-link-type="maybe"]::before {
    content: "‘";
}
[data-link-type="property"]::after,
[data-link-type="propdesc"]::after,
[data-link-type="descriptor"]::after,
[data-link-type="value"]::after,
[data-link-type="function"]::after,
[data-link-type="at-rule"]::after,
[data-link-type="selector"]::after,
[data-link-type="maybe"]::after {
    content: "’";
}

[data-link-type].production::before,
[data-link-type].production::after,
.prod [data-link-type]::before,
.prod [data-link-type]::after {
    content: "";
}

[data-link-type=element],
[data-link-type=element-attr] {
    font-family: Menlo, Consolas, "DejaVu Sans Mono", monospace;
    font-size: .9em;
}
[data-link-type=element]::before { content: "<" }
[data-link-type=element]::after  { content: ">" }

[data-link-type=biblio] {
    white-space: pre;
}

</style>
<style>/* Boilerplate: style-colors */
/* Any --*-text not paired with a --*-bg is assumed to have a transparent bg */
:root {
    color-scheme: light dark;

    --text: black;
    --bg: white;

    --unofficial-watermark: url(https://www.w3.org/StyleSheets/TR/2016/logos/UD-watermark);

    --logo-bg: #1a5e9a;
    --logo-active-bg: #c00;
    --logo-text: white;

    --tocnav-normal-text: #707070;
    --tocnav-normal-bg: var(--bg);
    --tocnav-hover-text: var(--tocnav-normal-text);
    --tocnav-hover-bg: #f8f8f8;
    --tocnav-active-text: #c00;
    --tocnav-active-bg: var(--tocnav-normal-bg);

    --tocsidebar-text: var(--text);
    --tocsidebar-bg: #f7f8f9;
    --tocsidebar-shadow: rgba(0,0,0,.1);
    --tocsidebar-heading-text: hsla(203,20%,40%,.7);

    --toclink-text: var(--text);
    --toclink-underline: #3980b5;
    --toclink-visited-text: var(--toclink-text);
    --toclink-visited-underline: #054572;

    --heading-text: #005a9c;

    --hr-text: var(--text);

    --algo-border: #def;

    --del-text: red;
    --del-bg: transparent;
    --ins-text: #080;
    --ins-bg: transparent;

    --a-normal-text: #034575;
    --a-normal-underline: #bbb;
    --a-visited-text: var(--a-normal-text);
    --a-visited-underline: #707070;
    --a-hover-bg: rgba(75%, 75%, 75%, .25);
    --a-active-text: #c00;
    --a-active-underline: #c00;

    --blockquote-border: silver;
    --blockquote-bg: transparent;
    --blockquote-text: currentcolor;

    --issue-border: #e05252;
    --issue-bg: #fbe9e9;
    --issue-text: var(--text);
    --issueheading-text: #831616;

    --example-border: #e0cb52;
    --example-bg: #fcfaee;
    --example-text: var(--text);
    --exampleheading-text: #574b0f;

    --note-border: #52e052;
    --note-bg: #e9fbe9;
    --note-text: var(--text);
    --noteheading-text: hsl(120, 70%, 30%);
    --notesummary-underline: silver;

    --assertion-border: #aaa;
    --assertion-bg: #eee;
    --assertion-text: black;

    --advisement-border: orange;
    --advisement-bg: #fec;
    --advisement-text: var(--text);
    --advisementheading-text: #b35f00;

    --warning-border: red;
    --warning-bg: hsla(40,100%,50%,0.95);
    --warning-text: var(--text);

    --amendment-border: #330099;
    --amendment-bg: #F5F0FF;
    --amendment-text: var(--text);
    --amendmentheading-text: #220066;

    --def-border: #8ccbf2;
    --def-bg: #def;
    --def-text: var(--text);
    --defrow-border: #bbd7e9;

    --datacell-border: silver;

    --indexinfo-text: #707070;

    --indextable-hover-text: black;
    --indextable-hover-bg: #f7f8f9;

    --outdatedspec-bg: rgba(0, 0, 0, .5);
    --outdatedspec-text: black;
    --outdated-bg: maroon;
    --outdated-text: white;
    --outdated-shadow: red;

    --editedrec-bg: darkorange;
}

</style>
<style>/* Boilerplate: style-counters */
body {
    counter-reset: example figure issue;
}
.issue {
    counter-increment: issue;
}
.issue:not(.no-marker)::before {
    content: "Issue " counter(issue);
}

.example {
    counter-increment: example;
}
.example:not(.no-marker)::before {
    content: "Example " counter(example);
}
.invalid.example:not(.no-marker)::before,
.illegal.example:not(.no-marker)::before {
    content: "Invalid Example" counter(example);
}

figcaption {
    counter-increment: figure;
}
figcaption:not(.no-marker)::before {
    content: "Figure " counter(figure) " ";
}
</style>
<style>/* Boilerplate: style-dfn-panel */
:root {
    --dfnpanel-bg: #ddd;
    --dfnpanel-text: var(--text);
    --dfnpanel-target-bg: #ffc;
    --dfnpanel-target-outline: orange;
}
.dfn-panel {
    position: absolute;
    z-index: 35;
    width: 20em;
    width: 300px;
    height: auto;
    max-height: 500px;
    overflow: auto;
    padding: 0.5em 0.75em;
    font: small Helvetica Neue, sans-serif, Droid Sans Fallback;
    background: var(--dfnpanel-bg);
    color: var(--dfnpanel-text);
    border: outset 0.2em;
    white-space: normal; /* in case it's moved into a pre */
}
.dfn-panel:not(.on) { display: none; }
.dfn-panel * { margin: 0; padding: 0; text-indent: 0; }
.dfn-panel > b { display: block; }
.dfn-panel a { color: var(--dfnpanel-text); }
.dfn-panel a:not(:hover) { text-decoration: none !important; border-bottom: none !important; }
.dfn-panel a:focus {
    outline: 5px auto Highlight;
    outline: 5px auto -webkit-focus-ring-color;
}
.dfn-panel > b + b { margin-top: 0.25em; }
.dfn-panel ul { padding: 0 0 0 1em; list-style: none; }
.dfn-panel li a {
    max-width: calc(300px - 1.5em - 1em);
    overflow: hidden;
    text-overflow: ellipsis;
}

.dfn-panel.activated {
    display: inline-block;
    position: fixed;
    left: 8px;
    bottom: 2em;
    margin: 0 auto;
    max-width: calc(100vw - 1.5em - .4em - .5em);
    max-height: 30vh;
    transition: left 1s ease-out, bottom 1s ease-out;
}

.dfn-panel .link-item:hover {
    text-decoration: underline;
}
.dfn-panel .link-item .copy-icon {
    opacity: 0;
}
.dfn-panel .link-item:hover .copy-icon,
.dfn-panel .link-item .copy-icon:focus {
    opacity: 1;
}

.dfn-panel .copy-icon {
    display: inline-block;
    margin-right: 0.5em;
    width: 0.85em;
    height: 1em;
    border-radius: 3px;
    background-color: #ccc;
    cursor: pointer;
}

.dfn-panel .copy-icon .icon {
    width: 100%;
    height: 100%;
    background-color: #fff;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
}

.dfn-panel .copy-icon .icon::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: 1px solid black;
    background-color: #ccc;
    opacity: 0.25;
    transform: translate(3px, -3px);
}

.dfn-panel .copy-icon:active .icon::before {
    opacity: 1;
}

.dfn-paneled[role="button"] { cursor: help; }

.highlighted {
    animation: target-fade 3s;
}

@keyframes target-fade {
    from {
        background-color: var(--dfnpanel-target-bg);
        outline: 5px solid var(--dfnpanel-target-outline);
    }
    to {
        color: var(--a-normal-text);
        background-color: transparent;
        outline: transparent;
    }
}
</style>
<style>/* Boilerplate: style-issues */
a[href].issue-return {
    float: right;
    float: inline-end;
    color: var(--issueheading-text);
    font-weight: bold;
    text-decoration: none;
}
</style>
<style>/* Boilerplate: style-md-lists */
/* This is a weird hack for me not yet following the commonmark spec
   regarding paragraph and lists. */
[data-md] > :first-child {
    margin-top: 0;
}
[data-md] > :last-child {
    margin-bottom: 0;
}
</style>
<style>/* Boilerplate: style-ref-hints */
:root {
    --ref-hint-bg: #ddd;
    --ref-hint-text: var(--text);
}

.ref-hint {
    display: inline-block;
    position: absolute;
    z-index: 35;
    width: 20em;
    width: 300px;
    height: auto;
    max-height: 500px;
    overflow: auto;
    padding: 0.5em 0.5em;
    font: small Helvetica Neue, sans-serif, Droid Sans Fallback;
    background: var(--ref-hint-bg);
    color: var(--ref-hint-text);
    border: outset 0.2em;
    white-space: normal; /* in case it's moved into a pre */
}

.ref-hint * { margin: 0; padding: 0; text-indent: 0; }

.ref-hint ul { padding: 0 0 0 1em; list-style: none; }
</style>
<style>/* Boilerplate: style-selflinks */
:root {
    --selflink-text: white;
    --selflink-bg: gray;
    --selflink-hover-text: black;
}
.heading, .issue, .note, .example, li, dt {
    position: relative;
}
a.self-link {
    position: absolute;
    top: 0;
    left: calc(-1 * (3.5rem - 26px));
    width: calc(3.5rem - 26px);
    height: 2em;
    text-align: center;
    border: none;
    transition: opacity .2s;
    opacity: .5;
}
a.self-link:hover {
    opacity: 1;
}
.heading > a.self-link {
    font-size: 83%;
}
.example > a.self-link,
.note > a.self-link,
.issue > a.self-link {
    /* These blocks are overflow:auto, so positioning outside
       doesn't work. */
    left: auto;
    right: 0;
}
li > a.self-link {
    left: calc(-1 * (3.5rem - 26px) - 2em);
}
dfn > a.self-link {
    top: auto;
    left: auto;
    opacity: 0;
    width: 1.5em;
    height: 1.5em;
    background: var(--selflink-bg);
    color: var(--selflink-text);
    font-style: normal;
    transition: opacity .2s, background-color .2s, color .2s;
}
dfn:hover > a.self-link {
    opacity: 1;
}
dfn > a.self-link:hover {
    color: var(--selflink-hover-text);
}

a.self-link::before            { content: "¶"; }
.heading > a.self-link::before { content: "§"; }
dfn > a.self-link::before      { content: "#"; }
</style>
<style>/* Boilerplate: style-syntax-highlighting */
code.highlight { padding: .1em; border-radius: .3em; }
pre.highlight, pre > code.highlight { display: block; padding: 1em; margin: .5em 0; overflow: auto; border-radius: 0; }

.highlight:not(.idl) { background: rgba(0, 0, 0, .03); }
c-[a] { color: #990055 } /* Keyword.Declaration */
c-[b] { color: #990055 } /* Keyword.Type */
c-[c] { color: #708090 } /* Comment */
c-[d] { color: #708090 } /* Comment.Multiline */
c-[e] { color: #0077aa } /* Name.Attribute */
c-[f] { color: #669900 } /* Name.Tag */
c-[g] { color: #222222 } /* Name.Variable */
c-[k] { color: #990055 } /* Keyword */
c-[l] { color: #000000 } /* Literal */
c-[m] { color: #000000 } /* Literal.Number */
c-[n] { color: #0077aa } /* Name */
c-[o] { color: #999999 } /* Operator */
c-[p] { color: #999999 } /* Punctuation */
c-[s] { color: #a67f59 } /* Literal.String */
c-[t] { color: #a67f59 } /* Literal.String.Single */
c-[u] { color: #a67f59 } /* Literal.String.Double */
c-[cp] { color: #708090 } /* Comment.Preproc */
c-[c1] { color: #708090 } /* Comment.Single */
c-[cs] { color: #708090 } /* Comment.Special */
c-[kc] { color: #990055 } /* Keyword.Constant */
c-[kn] { color: #990055 } /* Keyword.Namespace */
c-[kp] { color: #990055 } /* Keyword.Pseudo */
c-[kr] { color: #990055 } /* Keyword.Reserved */
c-[ld] { color: #000000 } /* Literal.Date */
c-[nc] { color: #0077aa } /* Name.Class */
c-[no] { color: #0077aa } /* Name.Constant */
c-[nd] { color: #0077aa } /* Name.Decorator */
c-[ni] { color: #0077aa } /* Name.Entity */
c-[ne] { color: #0077aa } /* Name.Exception */
c-[nf] { color: #0077aa } /* Name.Function */
c-[nl] { color: #0077aa } /* Name.Label */
c-[nn] { color: #0077aa } /* Name.Namespace */
c-[py] { color: #0077aa } /* Name.Property */
c-[ow] { color: #999999 } /* Operator.Word */
c-[mb] { color: #000000 } /* Literal.Number.Bin */
c-[mf] { color: #000000 } /* Literal.Number.Float */
c-[mh] { color: #000000 } /* Literal.Number.Hex */
c-[mi] { color: #000000 } /* Literal.Number.Integer */
c-[mo] { color: #000000 } /* Literal.Number.Oct */
c-[sb] { color: #a67f59 } /* Literal.String.Backtick */
c-[sc] { color: #a67f59 } /* Literal.String.Char */
c-[sd] { color: #a67f59 } /* Literal.String.Doc */
c-[se] { color: #a67f59 } /* Literal.String.Escape */
c-[sh] { color: #a67f59 } /* Literal.String.Heredoc */
c-[si] { color: #a67f59 } /* Literal.String.Interpol */
c-[sx] { color: #a67f59 } /* Literal.String.Other */
c-[sr] { color: #a67f59 } /* Literal.String.Regex */
c-[ss] { color: #a67f59 } /* Literal.String.Symbol */
c-[vc] { color: #0077aa } /* Name.Variable.Class */
c-[vg] { color: #0077aa } /* Name.Variable.Global */
c-[vi] { color: #0077aa } /* Name.Variable.Instance */
c-[il] { color: #000000 } /* Literal.Number.Integer.Long */

</style>
 <body class="h-entry">
  <div class="head">
   <p data-fill-with="logo"><a class="logo" href="https://www.w3.org/"> <img alt="W3C" height="48" src="https://www.w3.org/StyleSheets/TR/2021/logos/W3C" width="72"> </a> </p>
   <h1 class="p-name no-ref" id="title">Web Identity and Discovery</h1>
   <p id="w3c-state"><a href="https://www.w3.org/standards/types#ED">Editor’s Draft</a>, <time class="dt-updated" datetime="2024-02-21">21 February 2024</time></p>
   <details open>
    <summary>More details about this document</summary>
    <div data-fill-with="spec-metadata">
     <dl>
      <dt>This version:
      <dd><a class="u-url" href="https://www.w3.org/2005/Incubator/webid/spec/identity/">https://www.w3.org/2005/Incubator/webid/spec/identity/</a>
      <dt>Latest published version:
      <dd><a href="http://www.w3.org/TR/webid/">http://www.w3.org/TR/webid/</a>
      <dt>Previous Versions:
      <dd><a href="http://www.w3.org/2005/Incubator/webid/spec/drafts/" rel="prev">http://www.w3.org/2005/Incubator/webid/spec/drafts/</a>
      <dt>Feedback:
      <dd><a href="https://github.com/w3c/WebID/issues/">GitHub</a>
      <dt class="editor">Editor:
      <dd class="editor p-author h-card vcard"><a class="p-name fn u-email email" href="mailto:jacopo@scazzosi.com">Jacopo Scazzosi</a>
      <dt class="editor">Former Editors:
      <dd class="editor p-author h-card vcard"><a class="p-name fn u-email email" href="mailto:andrei@fcns.eu">Andrei Sambra</a>
      <dd class="editor p-author h-card vcard"><a class="p-name fn u-email email" href="mailto:scorlosquet@gmail.com">Stéphane Corlosquet</a>
     </dl>
    </div>
   </details>
   <div data-fill-with="warning"></div>
   <p class="copyright" data-fill-with="copyright"><a href="https://www.w3.org/policies/#copyright">Copyright</a> © 2024 <a href="https://www.w3.org/">World Wide Web Consortium</a>. <abbr title="World Wide Web Consortium">W3C</abbr><sup>®</sup> <a href="https://www.w3.org/policies/#Legal_Disclaimer">liability</a>, <a href="https://www.w3.org/policies/#W3C_Trademarks">trademark</a> and <a href="https://www.w3.org/copyright/software-license/" rel="license" title="W3C Software and Document License">permissive document license</a> rules apply. </p>
   <hr title="Separator for header">
  </div>
  <div class="p-summary" data-fill-with="abstract">
   <h2 class="no-num no-toc no-ref heading settled" id="abstract"><span class="content">Abstract</span></h2>
   <p>A global distributed Social Web requires that each person be able to control
their identity, that this identity be linkable across sites — placing each
person in a Web of relationships — and that it be possible to authenticate
globally with such identities.</p>
   <p>This specification outlines a simple universal identification mechanism that
is distributed, openly extensible, improves privacy, security and control
over how each person can identify themselves in order to allow fine grained
access control to their information on the Web. It does this by applying the
best practices of Web Architecture whilst building on well established widely
deployed protocols and standards including HTML, URIs, HTTP, and RDF
Semantics.</p>
   <h3 class="heading settled" id="how-to-read-this-document"><span class="content">How to Read this Document</span></h3>
   <p>There are a number of concepts that are covered in this document that the
reader may want to be aware of before continuing. General knowledge of RDF <a data-link-type="biblio" href="#biblio-rdf-primer" title="RDF Primer">[RDF-PRIMER]</a> is necessary to understand how to implement this
specification. This specification uses a number of specific technologies like
Turtle <a data-link-type="biblio" href="#biblio-turtle" title="RDF 1.1 Turtle">[TURTLE]</a> and RDFa <a data-link-type="biblio" href="#biblio-rdfa-core" title="RDFa Core 1.1 - Third Edition">[RDFA-CORE]</a>.</p>
   <p>A general <a href="#introduction">Introduction</a> is provided for all that would like
to understand why this specification is necessary to simplify usage of the Web.</p>
   <p>The terms used throughout this specification are listed in the section titled <a href="#terminology">Terminology</a>.</p>
  </div>
  <h2 class="no-num no-toc no-ref heading settled" id="sotd"><span class="content">Status of this document</span></h2>
  <div data-fill-with="status">
   <p></p>
   <p><em>This section describes the status of this document at the time of its
publication. Other documents may supersede this document. A list of current <abbr title="World Wide Web Consortium">W3C</abbr> publications and the
latest revision of this technical report can be found in the <a href="http://www.w3.org/TR/"><abbr title="World Wide Web
Consortium">W3C</abbr> technical reports index</a> at
http://www.w3.org/TR/.</em></p>
   <p>This document is produced from work by the <a href="http://www.w3.org/community/webid/"><abbr title="World Wide Web
Consortium">W3C</abbr> WebID Community Group</a>. This is an internal draft
document and may not even end up being officially published. It may also be
updated, replaced or obsoleted by other documents at any time. It is
inappropriate to cite this document as other than work in progress. The
source code for this document is available at the following URI:
https://dvcs.w3.org/hg/WebID</p>
   <p>This document was published by the <a href="http://www.w3.org/community/webid/">WebID CG</a> as an Editor’s Draft.
If you wish to make comments regarding this document, please send them to
public-webid@w3.org <a href="mailto:public-webid-request@w3.org?subject=subscribe">subscribe</a>, <a href="http://lists.w3.org/Archives/Public/public-webid/">archives</a>. All
comments are welcome.</p>
   <p>Publication as an Editor’s Draft does not imply endorsement by the <abbr title="World Wide Web Consortium">W3C</abbr> Membership. This is a draft
document and may be updated, replaced or obsoleted by other documents at any
time. It is inappropriate to cite this document as other than work in
progress.</p>
   <p>This document was produced by a group operating under the <a about href="http://www.w3.org/Consortium/Patent-Policy-20040205/" id="sotd_patent" rel="w3p:patentRules">5 February 2004 <abbr title="World Wide Web Consortium">W3C</abbr> Patent Policy</a>. <abbr title="World Wide Web Consortium">W3C</abbr> maintains a <a href="http://www.w3.org/2004/01/pp-impl/46065/status" rel="disclosure">public list of any
patent disclosures</a> made in connection with the deliverables of the group;
that page also includes instructions for disclosing a patent. An individual
who has actual knowledge of a patent which the individual believes contains <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential
Claim(s)</a> must disclose the information in accordance with <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section
6 of the <abbr title="World Wide Web Consortium">W3C</abbr> Patent
Policy</a>.</p>
  </div>
  <div data-fill-with="at-risk"></div>
  <main>
   <h2 class="heading settled" data-level="1" id="introduction"><span class="secno">1. </span><span class="content">Introduction</span><a class="self-link" href="#introduction"></a></h2>
   <p><em>This section is non-normative.</em></p>
   <p>A WebID is an HTTP URI that refers to an Agent (Person, Organization, Group,
Device, etc.); a description of the Agent named by the WebID can be found in 
the respective <a data-link-type="dfn" href="#webid-profile-document" id="ref-for-webid-profile-document">WebID Profile Document</a>.</p>
   <p>A <a data-link-type="dfn" href="#webid-profile-document" id="ref-for-webid-profile-document①">WebID Profile Document</a> is a Web resource that <em class="rfc2119">MUST</em> be available as <code>text/turtle</code> <a data-link-type="biblio" href="#biblio-turtle" title="RDF 1.1 Turtle">[TURTLE]</a>, but <em class="rfc2119">MAY</em> be available in other RDF serialization
formats (e.g., <a data-link-type="biblio" href="#biblio-rdfa-core" title="RDFa Core 1.1 - Third Edition">[RDFA-CORE]</a>) if requested through content negotiation.</p>
   <p>WebIDs can be used to build a Web of trust using vocabularies such as FOAF <a data-link-type="biblio" href="#biblio-foaf" title="FOAF Vocabulary Specification 0.99 (Paddington Edition)">[FOAF]</a> by allowing people to link their profiles in a public or protected
manner. Such a web of trust can then be used by a <a data-link-type="dfn" href="#service" id="ref-for-service">Service</a> to make
authorization decisions, by allowing access to resources depending on the
properties of an agent, such as that they are known by some relevant people,
employed at a given company, a member of a family or some other group, etc.</p>
   <p>This specification is for:</p>
   <ul>
    <li data-md>
     <p>Anyone who wants to understand the architectural principles and notions underlying WebIDs</p>
    <li data-md>
     <p>Content publishers who want to allocate identifiers to unambiguously name agents</p>
    <li data-md>
     <p>Server application developers who want to provide client applications with WebIDs and associated agent descriptions</p>
    <li data-md>
     <p>Client application developers who want to use a WebID to unambiguously identify their applications as agents</p>
    <li data-md>
     <p>Specification authors who want to extend any of the WebID specifications via Extension Profiles, e.g., identity authentication protocols</p>
   </ul>
   <h3 class="heading settled" data-level="1.1" id="outline"><span class="secno">1.1. </span><span class="content">Outline</span><a class="self-link" href="#outline"></a></h3>
   <p>This specification is divided in the following sections.</p>
   <p><a href="#introduction">This section</a> gives a high level overview of this
specification, and presents the organization of the specification and the
conventions used throughout this document.</p>
   <p><a href="#terminology">Section 2</a> provides a short description for the most commonly
used terms in this document.</p>
   <p><a href="#the-webid-http-uri">Section 3</a> describes what a WebID is.</p>
   <p><a href="#overview">Section 4</a> illustrates the relationship between a WebID, the Agent
that is named by it, and the respective <a data-link-type="dfn" href="#webid-profile-document" id="ref-for-webid-profile-document②">WebID Profile Document</a>.</p>
   <p><a href="#webid-profile-contents">Section 5</a> defines the required and some suggested
contents of a <a data-link-type="dfn" href="#webid-profile-document" id="ref-for-webid-profile-document③">WebID Profile Document</a></p>
   <p><a href="#publishing-the-webid-profile-document">Section 6</a> deals with the publishing
of a <a data-link-type="dfn" href="#webid-profile-document" id="ref-for-webid-profile-document④">WebID Profile Document</a>.</p>
   <p><a href="#processing-the-webid-profile">Section 7</a> describes how a request for a <a data-link-type="dfn" href="#webid-profile-document" id="ref-for-webid-profile-document⑤">WebID Profile Document</a> should be handled.</p>
   <h2 class="heading settled" data-level="2" id="terminology"><span class="secno">2. </span><span class="content">Terminology</span><a class="self-link" href="#terminology"></a></h2>
   <p>This section provides definitions for several important terms used in this
document.</p>
   <dl>
    <dt data-md><dfn class="dfn-paneled" data-dfn-type="dfn" data-noexport id="requesting-agent">Requesting Agent</dfn>
    <dd data-md>
     <p>The Requesting Agent initiates a request to a Service listening on a
specific port using a given protocol on a given Server.</p>
    <dt data-md><dfn class="dfn-paneled" data-dfn-type="dfn" data-noexport id="server">Server</dfn>
    <dd data-md>
     <p>A Server is a physical or virtual machine, contactable at a domain name or
IP address, that hosts Services which are accessible over the network.</p>
    <dt data-md><dfn class="dfn-paneled" data-dfn-type="dfn" data-noexport id="service">Service</dfn>
    <dd data-md>
     <p>A Service is an agent listening for requests at a particular domain name or
IP address on a given Server.</p>
    <dt data-md><dfn class="dfn-paneled" data-dfn-type="dfn" data-noexport id="webid">WebID</dfn>
    <dd data-md>
     <p>An identifier in the form of an HTTP URI that unambiguously names an Agent
and, when dereferenced, always leads to a <a data-link-type="dfn" href="#webid-profile-document" id="ref-for-webid-profile-document⑥">WebID Profile Document</a> which itself indicates that it describes the Agent named by the WebID.</p>
    <dt data-md><dfn class="dfn-paneled" data-dfn-type="dfn" data-noexport id="webid-profile-document">WebID Profile Document</dfn>
    <dd data-md>
     <p>An RDF document that describes an Agent.</p>
    <dt data-md><dfn class="dfn-paneled" data-dfn-type="dfn" data-noexport id="agent">Agent</dfn>
    <dd data-md>
     <p>An entity that performs or can perform an action, e.g., a person, an organization, a device.</p>
   </dl>
   <h3 class="heading settled" data-level="2.1" id="namespaces"><span class="secno">2.1. </span><span class="content">Namespaces</span><a class="self-link" href="#namespaces"></a></h3>
   <p>Examples assume the following namespace prefix bindings unless otherwise
stated:</p>
   <table class="prefixes">
    <thead>
     <tr>
      <th>Prefix
      <th>IRI
    <tbody>
     <tr>
      <td><code>foaf</code>
      <td>http://xmlns.com/foaf/0.1/
   </table>
   <h2 class="heading settled" data-level="3" id="the-webid-http-uri"><span class="secno">3. </span><span class="content">The WebID HTTP URI</span><a class="self-link" href="#the-webid-http-uri"></a></h2>
   <p>When using URIs, it is possible to identify both a thing (which may exist
outside of the Web) and a Web document describing the thing. For example, the
person Bob is described on his homepage. Alice may not like the look of Bob’s
homepage, but may want to link to the person Bob. Therefore, two URIs are
needed, one for Bob and one for Bob’s homepage (or an RDF document describing
Bob).</p>
   <p>The WebID HTTP URI must be one that dereferences to a document the user
controls.</p>
   <p>For example, if a user Bob controls <code>https://bob.example.org/profile</code>, then his
WebID can be <code>https://bob.example.org/profile#me</code>.</p>
   <div class="note" id="h_note_1" role="note">
    <a class="self-link" href="#h_note_1"></a> 
    <p>There are two solutions that meet our requirements for identifying real-world
  objects: 303 redirects and hash URIs. Which one to use depends on the
  situation. Both have advantages and disadvantages, as presented in <a data-link-type="biblio" href="#biblio-cooluris" title="Cool URIs for the Semantic Web">[COOLURIS]</a>. All examples in this specification will use such hash URIs.</p>
   </div>
   <h2 class="heading settled" data-level="4" id="overview"><span class="secno">4. </span><span class="content">Overview</span><a class="self-link" href="#overview"></a></h2>
   <p><em>This section is non-normative.</em></p>
   <p>The relation between the <a data-link-type="dfn" href="#webid" id="ref-for-webid">WebID</a> URI and the <a data-link-type="dfn" href="#webid-profile-document" id="ref-for-webid-profile-document⑦">WebID Profile Document</a> is
illustrated below.</p>
   <p><img alt="WebID overview" class="full-width" height="851" id="webid-diagram" src="img/WebID-overview.png" width="1311"></p>
   <p>The WebID URI — <em>"<a href="http://www.w3.org/People/Berners-Lee/card#i">http://www.w3.org/People/Berners-Lee/card<strong>#i</strong></a>"</em> (containing the <strong>#i</strong> hash tag) — is an identifier that denotes (refers to) a
person or more generally an agent. In the above illustration, the referent is
Tim Berners Lee, a real physical person who has a history, who invented the
World Wide Web, and who directs the World Web Consortium.</p>
   <p>The WebID Profile Document URI — <em>"<a href="http://www.w3.org/People/Berners-Lee/card">http://www.w3.org/People/Berners-Lee/card</a>"</em> (without the <strong>#i</strong> hash
tag) — denotes the document describing the person (or more generally any agent)
who is the referent of the WebID URI.</p>
   <p>The WebID Profile Document gives the meaning of the WebID: its RDF Graph
contains a <a href="http://www.w3.org/Submission/CBD/">Concise Bounded Description</a> of
the WebID such that this subgraph forms a definite description of the referent
of the WebID, that is, a description that distinguishes the referent of that
WebID from all other things in the world. <br> The WebID Profile Document
can, for example, contain relations to other documents depicting the WebID
referent, or it can relate the WebID to principals used by different
authentication protocols. (More information on WebID and other authentication
protocols can be found on the <a href="http://www.w3.org/2005/Incubator/webid/wiki/Identity_Interoperability">WebID Identity
Interoperability</a> page).</p>
   <h2 class="heading settled" data-level="5" id="publishing-the-webid-profile-document"><span class="secno">5. </span><span class="content">Publishing the WebID Profile Document</span><a class="self-link" href="#publishing-the-webid-profile-document"></a></h2>
   <p>This specification requires that servers <em class="rfc2119">MUST</em> at least be able to provide a
Turtle representation of WebID Profile Documents, but other serialization
formats of the graph are allowed, provided that agents are able to parse that
serialization and obtain the graph automatically. HTTP Content Negotiation can
be employed to aid in publication and discovery of multiple distinct
serializations of the same graph at the same URL, as explained in <a data-link-type="biblio" href="#biblio-cooluris" title="Cool URIs for the Semantic Web">[COOLURIS]</a></p>
   <p>It is particularly useful to have one of the representations be in HTML even if
it is not marked up in RDFa, as this allows people using a web browser to
understand what the information at that URI represents.</p>
   <h3 class="heading settled" data-level="5.1" id="webid-profile-vocabulary"><span class="secno">5.1. </span><span class="content">WebID Profile Document Vocabulary</span><a class="self-link" href="#webid-profile-vocabulary"></a></h3>
   <p>WebID RDF graphs are built using vocabularies identified by URIs, that can be
placed in subject, predicate or object position of the relations constituting
the graph. The definition of each URI should be found at the namespace of the
URI, by dereferencing it.</p>
   <h4 class="heading settled" data-level="5.1.1" id="webid-profile-contents"><span class="secno">5.1.1. </span><span class="content">Contents of a WebID Profile Document</span><a class="self-link" href="#webid-profile-contents"></a></h4>
   <p>A <a data-link-type="dfn" href="#webid-profile-document" id="ref-for-webid-profile-document⑧">WebID Profile Document</a> <em class="rfc2119">MUST</em> qualify the described Agent as the
document’s <code>foaf:primaryTopic</code>. Furthermore, a <a data-link-type="dfn" href="#webid-profile-document" id="ref-for-webid-profile-document⑨">WebID Profile Document</a> <em class="rfc2119">SHOULD</em> also qualify the described Agent as having type <code>foaf:Agent</code>.</p>
   <p>Personal details are the most common requirement when registering an account
with a website. Some of these pieces of information include an e-mail address,
a name and perhaps an avatar image, expressed using the FOAF <a data-link-type="biblio" href="#biblio-foaf" title="FOAF Vocabulary Specification 0.99 (Paddington Edition)">[FOAF]</a> vocabulary. This section includes properties that <em class="rfc2119">SHOULD</em> be used when
conveying key pieces of personal information but are <em class="rfc2119" title="NOT REQUIRED">NOT REQUIRED</em> to be present in a <a data-link-type="dfn" href="#webid-profile-document" id="ref-for-webid-profile-document①⓪">WebID Profile
Document</a>:</p>
   <dl>
    <dt data-md>foaf:name
    <dd data-md>
     <p>The name of the individual or agent.</p>
    <dt data-md>foaf:knows
    <dd data-md>
     <p>The WebID URI of a known person.</p>
    <dt data-md>foaf:img
    <dd data-md>
     <p>An image representing a person.</p>
   </dl>
   <h3 class="heading settled" data-level="5.2" id="publishing-a-webid-profile-using-turtle"><span class="secno">5.2. </span><span class="content">Publishing a WebID Profile using Turtle ##</span><a class="self-link" href="#publishing-a-webid-profile-using-turtle"></a></h3>
    {#publishing-a-webid-profile-using-turtle} 
   <p><em>This section is non-normative.</em></p>
   <p>A widely used format for writing RDF graphs by hand is the <a href="http://www.w3.org/TR/turtle/">Turtle</a> <a data-link-type="biblio" href="#biblio-turtle" title="RDF 1.1 Turtle">[TURTLE]</a> notation. It is easy to
learn, and very handy for communicating over e-mail and on mailing lists. The
syntax is very similar to the <a href="http://www.w3.org/TR/rdf-sparql-query/">SPARQL</a> query language. WebID Profile Documents in Turtle should be served with the <code>text/turtle</code> content type.</p>
   <p>Take for example the WebID <em>https://bob.example.org/profile#me</em>, for which the
WebID Profile Document contains the following Turtle representation:</p>
   <div class="example" id="ex-webid-profile-turtle">
    <a class="self-link" href="#ex-webid-profile-turtle"></a> 
<pre class="highlight"><c- k>@prefix</c-> <c- nn>foaf:</c-> <c- g>&lt;http://xmlns.com/foaf/0.1/></c-> <c- p>.</c->

<c- g>&lt;></c-> <c- b>a</c-> <c- nn>foaf</c-><c- p>:</c-><c- f>PersonalProfileDocument</c-> <c- p>;</c->
  <c- nn>foaf</c-><c- p>:</c-><c- f>maker</c-> <c- g>&lt;#me></c-> <c- p>;</c->
  <c- nn>foaf</c-><c- p>:</c-><c- f>primaryTopic</c-> <c- g>&lt;#me></c-> <c- p>.</c->

<c- g>&lt;#me></c-> <c- b>a</c-> <c- nn>foaf</c-><c- p>:</c-><c- f>Person</c-> <c- p>;</c->
  <c- nn>foaf</c-><c- p>:</c-><c- f>name</c-> <c- s>"Bob"</c-> <c- p>;</c->
  <c- nn>foaf</c-><c- p>:</c-><c- f>knows</c-> <c- g>&lt;https://example.edu/p/Alice#MSc></c-> <c- p>;</c->
  <c- nn>foaf</c-><c- p>:</c-><c- f>img</c-> <c- g>&lt;https://bob.example.org/picture.jpg></c-> <c- p>.</c->
</pre>
   </div>
   <h3 class="heading settled" data-level="5.3" id="publishing-a-webid-profile-using-the-rdfa-html-notation"><span class="secno">5.3. </span><span class="content">Publishing a WebID Profile Document using the RDFa HTML notation</span><a class="self-link" href="#publishing-a-webid-profile-using-the-rdfa-html-notation"></a></h3>
   <p><em>This section is non-normative.</em></p>
   <p>RDFa in HTML <a data-link-type="biblio" href="#biblio-rdfa-core" title="RDFa Core 1.1 - Third Edition">[RDFA-CORE]</a> is a way to markup HTML with relations that have a
well defined semantics and mapping to an RDF graph. There are many ways of
writing out the above graph using RDFa in HTML. Here is just one example of
what a WebID Profile Document could look like.</p>
   <div class="example" id="ex-webid-profile-rdfa">
    <a class="self-link" href="#ex-webid-profile-rdfa"></a> 
<pre class="highlight"><c- p>&lt;</c-><c- f>div</c-> <c- e>vocab</c-><c- o>=</c-><c- s>"http://xmlns.com/foaf/0.1/"</c-> <c- e>about</c-><c- o>=</c-><c- s>"#me"</c-> <c- e>typeof</c-><c- o>=</c-><c- s>"foaf:Person"</c-><c- p>></c->
  <c- p>&lt;</c-><c- f>p</c-><c- p>></c->My name is <c- p>&lt;</c-><c- f>span</c-> <c- e>property</c-><c- o>=</c-><c- s>"name"</c-><c- p>></c->Bob<c- p>&lt;/</c-><c- f>span</c-><c- p>></c-> and this is how I look like: <c- p>&lt;</c-><c- f>img</c-> <c- e>property</c-><c- o>=</c-><c- s>"img"</c-> <c- e>src</c-><c- o>=</c-><c- s>"https://bob.example.org/picture.jpg"</c-> <c- e>title</c-><c- o>=</c-><c- s>"Bob"</c-> <c- e>alt</c-><c- o>=</c-><c- s>"Bob"</c-> <c- p>/>&lt;/</c-><c- f>p</c-><c- p>></c->
  <c- p>&lt;</c-><c- f>h2</c-><c- p>></c->My Good Friends<c- p>&lt;/</c-><c- f>h2</c-><c- p>></c->
  <c- p>&lt;</c-><c- f>ul</c-><c- p>></c->
    <c- p>&lt;</c-><c- f>li</c-> <c- e>property</c-><c- o>=</c-><c- s>"knows"</c-> <c- e>href</c-><c- o>=</c-><c- s>"https://example.edu/p/Alice#MSc"</c-><c- p>></c->Alice<c- p>&lt;/</c-><c- f>li</c-><c- p>></c->
  <c- p>&lt;/</c-><c- f>ul</c-><c- p>></c->
<c- p>&lt;/</c-><c- f>div</c-><c- p>></c->
</pre>
   </div>
   <p>If a WebID provider would prefer not to mark up his WebID Profile Document in
HTML+RDFa, but just provide a human readable format for users in plain HTML and
have the RDF graph appear in a machine readable format such as Turtle, then he <em class="rfc2119">SHOULD</em> provide a link of type <code>alternate</code> to a machine readable format <a data-link-type="biblio" href="#biblio-rfc5988" title="Web Linking">[RFC5988]</a>. This can be placed in the HTTP header or in the html as shown
here:</p>
   <div class="example" id="webid-profile-link">
    <a class="self-link" href="#webid-profile-link"></a> 
<pre class="highlight"><c- p>&lt;</c-><c- f>html</c-><c- p>></c->
  <c- p>&lt;</c-><c- f>head</c-><c- p>></c->
    <c- p>&lt;</c-><c- f>link</c-> <c- e>rel</c-><c- o>=</c-><c- s>"alternate"</c-> <c- e>type</c-><c- o>=</c-><c- s>"text/turtle"</c-> <c- e>href</c-><c- o>=</c-><c- s>"profile.ttl"</c-><c- p>/></c->
  <c- p>&lt;/</c-><c- f>head</c-><c- p>></c->
  <c- p>&lt;</c-><c- f>body</c-><c- p>></c-> ... <c- p>&lt;/</c-><c- f>body</c-><c- p>></c->
<c- p>&lt;/</c-><c- f>html</c-><c- p>></c->
</pre>
   </div>
   <h3 class="heading settled" data-level="5.4" id="privacy"><span class="secno">5.4. </span><span class="content">Privacy</span><a class="self-link" href="#privacy"></a></h3>
   <p><em>This section is non-normative.</em></p>
   <p>A WebID Profile Document may contain public as well as private information
about the agent named by the WebID. As some agents may not want to reveal
a lot of information about themselves, RDF and Linked Data principles allows
them to choose how much information they wish to make publicly available. This
can be achieved by separating parts of the profile information into separate
documents, each protected by access control policies.</p>
   <p>On the other hand, some agents may want to publish more information about
themselves, but only to a select group of trusted agents. In the following
example, Bob is limiting access to his list of friends, by placing all <em>foaf:knows</em> relations into a separate document.</p>
   <div class="example" id="ex-privacy-profile">
    <a class="self-link" href="#ex-privacy-profile"></a> 
<pre class="highlight"><c- k>@prefix</c-> <c- nn>foaf:</c-> <c- g>&lt;http://xmlns.com/foaf/0.1/></c-> <c- p>.</c->
<c- k>@prefix</c-> <c- nn>rdfs:</c-> <c- g>&lt;http://www.w3.org/2000/01/rdf-schema#></c-> <c- p>.</c->

<c- g>&lt;></c-> <c- b>a</c-> <c- nn>foaf</c-><c- p>:</c-><c- f>PersonalProfileDocument</c-> <c- p>;</c->
  <c- nn>foaf</c-><c- p>:</c-><c- f>maker</c-> <c- g>&lt;#me></c-> <c- p>;</c->
  <c- nn>foaf</c-><c- p>:</c-><c- f>primaryTopic</c-> <c- g>&lt;#me></c-> <c- p>.</c->

<c- g>&lt;#me></c-> <c- b>a</c-> <c- nn>foaf</c-><c- p>:</c-><c- f>Person</c-> <c- p>;</c->
  <c- nn>foaf</c-><c- p>:</c-><c- f>name</c-> <c- s>"Bob"</c-> <c- p>;</c->
  <strong><c- nn>rdfs</c-><c- p>:</c-><c- f>seeAlso</c-> <c- g>&lt;https://bob.example.org/friends></c-> <c- p>;</c-></strong>
  <c- nn>foaf</c-><c- p>:</c-><c- f>img</c-> <c- g>&lt;https://bob.example.org/picture.jpg></c-> <c- p>.</c->
</pre>
   </div>
   <p>Where https://bob.example.org/friends is a reference to an Access Control List
(ACL) protected document containing:</p>
   <div class="example" id="ex-privacy-seeAlso">
    <a class="self-link" href="#ex-privacy-seeAlso"></a> 
<pre class="highlight"><c- k>@prefix</c-> <c- nn>foaf:</c-> <c- g>&lt;http://xmlns.com/foaf/0.1/></c-> <c- p>.</c->

<c- g>&lt;></c-> <c- b>a</c-> <c- nn>foaf</c-><c- p>:</c-><c- f>PersonalProfileDocument</c-> <c- p>;</c->
  <c- nn>foaf</c-><c- p>:</c-><c- f>maker</c-> <c- g>&lt;https://bob.example.org/profile#me></c-> <c- p>;</c->
  <c- nn>foaf</c-><c- p>:</c-><c- f>primaryTopic</c-> <c- g>&lt;https://bob.example.org/profile#me></c-> <c- p>.</c->

<c- g>&lt;https://bob.example.org/profile#me></c-> <c- b>a</c-> <c- nn>foaf</c-><c- p>:</c-><c- f>Person</c-> <c- p>;</c->
  <c- nn>foaf</c-><c- p>:</c-><c- f>knows</c-> <c- g>&lt;https://example.edu/p/Alice#MSc></c-> <c- p>;</c->
  <c- nn>foaf</c-><c- p>:</c-><c- f>knows</c-> <c- g>&lt;https://example.com/people/Mary/card#me></c-> <c- p>.</c->
</pre>
   </div>
   <p>and having the following corresponding ACL rule, expressed using the <a href="http://www.w3.org/wiki/WebAccessControl">WebAccessControl</a> ontology:</p>
   <div class="example" id="ex-privacy-acl">
    <a class="self-link" href="#ex-privacy-acl"></a> 
<pre class="highlight"><c- k>@prefix</c-> <c- nn>acl:</c-> <c- g>&lt;http://www.w3.org/ns/auth/acl#></c-> <c- p>.</c->

<c- g>&lt;#FriendsOnly></c-> <c- p>;</c->
  <c- nn>acl</c-><c- p>:</c-><c- f>accessTo</c-> <c- g>&lt;https://bob.example.org/friends></c-> <c- p>;</c->
  <c- nn>acl</c-><c- p>:</c-><c- f>agent</c-> <c- g>&lt;http://example.edu/p/Alice#Msc></c-><c- p>,</c-> <c- g>&lt;http://example.com/people/Mary/card#me></c-> <c- p>;</c->
  <c- nn>acl</c-><c- p>:</c-><c- f>mode</c-> <c- nn>acl</c-><c- p>:</c-><c- f>Read</c-> <c- p>.</c->
</pre>
   </div>
   <h3 class="heading settled" data-level="5.5" id="security-considerations"><span class="secno">5.5. </span><span class="content">Security Considerations</span><a class="self-link" href="#security-considerations"></a></h3>
   <p><em>This section is non-normative.</em></p>
   <p>A <a data-link-type="dfn" href="#webid" id="ref-for-webid①">WebID</a> identifies an agent via a description found in the associated <a data-link-type="dfn" href="#webid-profile-document" id="ref-for-webid-profile-document①①">WebID Profile Document</a>. An agent that wishes to know what a WebID refers
to, must rely on the description found in the WebID Profile. An attack on the
relation between the <a data-link-type="dfn" href="#webid" id="ref-for-webid②">WebID</a> and the <a data-link-type="dfn" href="#webid-profile-document" id="ref-for-webid-profile-document①②">WebID Profile Document</a> can thus be
used to subvert the meaning of the WebID, and to make agents following links
within the <a data-link-type="dfn" href="#webid-profile-document" id="ref-for-webid-profile-document①③">WebID Profile Document</a> come to different conclusions from those
intended by profile owners.</p>
   <p>The standard way of overcoming such attacks is to rely on the cryptographic
security protocols within the HTTPS <a data-link-type="biblio" href="#biblio-http-tls" title="HTTP Semantics">[HTTP-TLS]</a> stack. HTTPS servers are
identified by a certificate either signed by a well known Certification
Authority or whose public key is listed in the DNSSEC as specified by the DANE
protocol <a data-link-type="biblio" href="#biblio-rfc6698" title="The DNS-Based Authentication of Named Entities (DANE) Transport Layer Security (TLS) Protocol: TLSA">[RFC6698]</a>, or both. This makes it much more difficult to set up a
fake server by DNS Poisoning attacks. Resources served over HTTPS are
furthermore signed and encrypted removing all the simple man-in-the-middle
attacks. Applying the above security measure does not remove the burden from
server administrators to take the appropriate security measures, in order to
avoid compromising their servers. Similarly, clients that fetch documents on
the web also need to make sure their work environment has not bee
compromised.</p>
   <p>As security is constantly being challenged by new attacks, to which new
responses are found, a collection of security considerations will be made
available on the <a href="http://www.w3.org/2005/Incubator/webid/wiki/Identity_Security">WebID
Wiki</a>.</p>
   <h2 class="heading settled" data-level="6" id="processing-the-webid-profile"><span class="secno">6. </span><span class="content">Processing the WebID Profile</span><a class="self-link" href="#processing-the-webid-profile"></a></h2>
   <p>The <a data-link-type="dfn" href="#requesting-agent" id="ref-for-requesting-agent">Requesting Agent</a> needs to fetch the WebID Profile Document, if it does
not have a valid one in cache. The Agent requesting the WebID Profile Document <em class="rfc2119">MUST</em> be able to parse documents in Turtle <a data-link-type="biblio" href="#biblio-turtle" title="RDF 1.1 Turtle">[TURTLE]</a>, but <em class="rfc2119">MAY</em> also be able
to parse documents in RDF/XML <a data-link-type="biblio" href="#biblio-rdf-syntax-grammar" title="RDF Test Cases">[RDF-SYNTAX-GRAMMAR]</a> and RDFa <a data-link-type="biblio" href="#biblio-rdfa-core" title="RDFa Core 1.1 - Third Edition">[RDFA-CORE]</a>.
The result of this processing should be a graph of RDF relations that is
queryable, as explained in the next section.</p>
   <div class="note" id="note-qvalue" role="note">
    <a class="self-link" href="#note-qvalue"></a> 
    <p>It is recommended that the <a data-link-type="dfn" href="#requesting-agent" id="ref-for-requesting-agent①">Requesting Agent</a> sets a <em>qvalue</em> for <code>text/turtle</code> in the HTTP <code>Accept-Header</code> with a higher priority than in the
  case of <code>application/xhtml+xml</code> or <code>text/html</code>, as sites may produce HTML
  without RDFa markup but with a link to graph encoded in a pure RDF format
  such as Turtle. For an agent that can parse Turtle, rdf/xml and RDFa, the
  following would be a reasonable Accept header: <br> <code>Accept: text/turtle,application/rdf+xml,application/xhtml+xml;q=0.8,text/html;q=0.7</code></p>
   </div>
   <p>If the <a data-link-type="dfn" href="#requesting-agent" id="ref-for-requesting-agent②">Requesting Agent</a> wishes to have the most up-to-date WebID Profile
Document for an HTTP URL, it can use the HTTP cache control headers to get the
latest versions.</p>
   <h2 class="heading settled" data-level="7" id="acknowledgments"><span class="secno">7. </span><span class="content">Acknowledgments</span><a class="self-link" href="#acknowledgments"></a></h2>
   <p><em>This section is non-normative.</em></p>
   <p>The following people have been instrumental in providing thoughts, feedback,
reviews, criticism and input in the creation of this specification:</p>
   <p>Stéphane Corlosquet, Erich Bremer, Kingsley Idehen, Ted Thibodeau, Alexandre
Bertails, Thomas Bergwinkl.</p>
  </main>
<script src="https://www.w3.org/scripts/TR/2021/fixup.js"></script>
  <h2 class="no-num no-ref heading settled" id="references"><span class="content">References</span><a class="self-link" href="#references"></a></h2>
  <h3 class="no-num no-ref heading settled" id="normative"><span class="content">Normative References</span><a class="self-link" href="#normative"></a></h3>
  <dl>
   <dt id="biblio-cooluris">[COOLURIS]
   <dd>Leo Sauermann; Richard Cyganiak. <a href="https://www.w3.org/TR/cooluris/"><cite>Cool URIs for the Semantic Web</cite></a>. 3 December 2008. NOTE. URL: <a href="https://www.w3.org/TR/cooluris/">https://www.w3.org/TR/cooluris/</a>
   <dt id="biblio-foaf">[FOAF]
   <dd>Dan Brickley; Libby Miller. <a href="http://xmlns.com/foaf/spec"><cite>FOAF Vocabulary Specification 0.99 (Paddington Edition)</cite></a>. 14 January 2014. URL: <a href="http://xmlns.com/foaf/spec">http://xmlns.com/foaf/spec</a>
   <dt id="biblio-http-tls">[HTTP-TLS]
   <dd>R. Fielding, Ed.; M. Nottingham, Ed.; J. Reschke, Ed.. <a href="https://httpwg.org/specs/rfc9110.html"><cite>HTTP Semantics</cite></a>. June 2022. Internet Standard. URL: <a href="https://httpwg.org/specs/rfc9110.html">https://httpwg.org/specs/rfc9110.html</a>
   <dt id="biblio-rdf-primer">[RDF-PRIMER]
   <dd>Frank Manola; Eric Miller. <a href="https://w3c.github.io/rdf-primer/spec/"><cite>RDF Primer</cite></a>. URL: <a href="https://w3c.github.io/rdf-primer/spec/">https://w3c.github.io/rdf-primer/spec/</a>
   <dt id="biblio-rdf-syntax-grammar">[RDF-SYNTAX-GRAMMAR]
   <dd>jan grant; Dave Beckett. <a href="https://www.w3.org/TR/rdf-testcases/"><cite>RDF Test Cases</cite></a>. 10 February 2004. REC. URL: <a href="https://www.w3.org/TR/rdf-testcases/">https://www.w3.org/TR/rdf-testcases/</a>
   <dt id="biblio-rdfa-core">[RDFA-CORE]
   <dd>Ben Adida; et al. <a href="https://www.w3.org/TR/rdfa-core/"><cite>RDFa Core 1.1 - Third Edition</cite></a>. 17 March 2015. REC. URL: <a href="https://www.w3.org/TR/rdfa-core/">https://www.w3.org/TR/rdfa-core/</a>
   <dt id="biblio-rfc5988">[RFC5988]
   <dd>M. Nottingham. <a href="https://httpwg.org/specs/rfc8288.html"><cite>Web Linking</cite></a>. October 2017. Proposed Standard. URL: <a href="https://httpwg.org/specs/rfc8288.html">https://httpwg.org/specs/rfc8288.html</a>
   <dt id="biblio-rfc6698">[RFC6698]
   <dd>P. Hoffman; J. Schlyter. <a href="https://www.rfc-editor.org/rfc/rfc6698"><cite>The DNS-Based Authentication of Named Entities (DANE) Transport Layer Security (TLS) Protocol: TLSA</cite></a>. August 2012. Proposed Standard. URL: <a href="https://www.rfc-editor.org/rfc/rfc6698">https://www.rfc-editor.org/rfc/rfc6698</a>
   <dt id="biblio-turtle">[TURTLE]
   <dd>Eric Prud'hommeaux; Gavin Carothers. <a href="https://w3c.github.io/rdf-turtle/spec/"><cite>RDF 1.1 Turtle</cite></a>. URL: <a href="https://w3c.github.io/rdf-turtle/spec/">https://w3c.github.io/rdf-turtle/spec/</a>
  </dl>
<script>/* Boilerplate: script-dom-helper */
"use strict";
function query(sel) { return document.querySelector(sel); }

function queryAll(sel) { return [...document.querySelectorAll(sel)]; }

function iter(obj) {
	if(!obj) return [];
	var it = obj[Symbol.iterator];
	if(it) return it;
	return Object.entries(obj);
}

function mk(tagname, attrs, ...children) {
	const el = document.createElement(tagname);
	for(const [k,v] of iter(attrs)) {
		if(k.slice(0,3) == "_on") {
			const eventName = k.slice(3);
			el.addEventListener(eventName, v);
		} else if(k[0] == "_") {
			// property, not attribute
			el[k.slice(1)] = v;
		} else {
			if(v === false || v == null) {
        continue;
      } else if(v === true) {
        el.setAttribute(k, "");
        continue;
      } else {
  			el.setAttribute(k, v);
      }
		}
	}
	append(el, children);
	return el;
}

/* Create shortcuts for every known HTML element */
[
  "a",
  "abbr",
  "acronym",
  "address",
  "applet",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "basefont",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "center",
  "cite",
  "code",
  "col",
  "colgroup",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "font",
  "footer",
  "form",
  "frame",
  "frameset",
  "head",
  "header",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "meta",
  "meter",
  "nav",
  "nobr",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "pre",
  "progress",
  "q",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strike",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  "xmp",
].forEach(tagname=>{
	mk[tagname] = (...args) => mk(tagname, ...args);
});

function* nodesFromChildList(children) {
	for(const child of children.flat(Infinity)) {
		if(child instanceof Node) {
			yield child;
		} else {
			yield new Text(child);
		}
	}
}
function append(el, ...children) {
	for(const child of nodesFromChildList(children)) {
		if(el instanceof Node) el.appendChild(child);
		else el.push(child);
	}
	return el;
}

function insertAfter(el, ...children) {
	for(const child of nodesFromChildList(children)) {
		el.parentNode.insertBefore(child, el.nextSibling);
	}
	return el;
}

function clearContents(el) {
	el.innerHTML = "";
	return el;
}

function parseHTML(markup) {
	if(markup.toLowerCase().trim().indexOf('<!doctype') === 0) {
		const doc = document.implementation.createHTMLDocument("");
		doc.documentElement.innerHTML = markup;
		return doc;
	} else {
		const el = mk.template({});
		el.innerHTML = markup;
		return el.content;
	}
}</script>
<script>/* Boilerplate: script-dfn-panel */
"use strict";
{
let dfnPanelData = {
"agent": {"dfnID":"agent","dfnText":"Agent","external":false,"refSections":[],"url":"#agent"},
"requesting-agent": {"dfnID":"requesting-agent","dfnText":"Requesting Agent","external":false,"refSections":[{"refs":[{"id":"ref-for-requesting-agent"},{"id":"ref-for-requesting-agent\u2460"},{"id":"ref-for-requesting-agent\u2461"}],"title":"6. Processing the WebID Profile"}],"url":"#requesting-agent"},
"server": {"dfnID":"server","dfnText":"Server","external":false,"refSections":[],"url":"#server"},
"service": {"dfnID":"service","dfnText":"Service","external":false,"refSections":[{"refs":[{"id":"ref-for-service"}],"title":"1. Introduction"}],"url":"#service"},
"webid": {"dfnID":"webid","dfnText":"WebID","external":false,"refSections":[{"refs":[{"id":"ref-for-webid"}],"title":"4. Overview"},{"refs":[{"id":"ref-for-webid\u2460"},{"id":"ref-for-webid\u2461"}],"title":"5.5. Security Considerations"}],"url":"#webid"},
"webid-profile-document": {"dfnID":"webid-profile-document","dfnText":"WebID Profile Document","external":false,"refSections":[{"refs":[{"id":"ref-for-webid-profile-document"},{"id":"ref-for-webid-profile-document\u2460"}],"title":"1. Introduction"},{"refs":[{"id":"ref-for-webid-profile-document\u2461"},{"id":"ref-for-webid-profile-document\u2462"},{"id":"ref-for-webid-profile-document\u2463"},{"id":"ref-for-webid-profile-document\u2464"}],"title":"1.1. Outline"},{"refs":[{"id":"ref-for-webid-profile-document\u2465"}],"title":"2. Terminology"},{"refs":[{"id":"ref-for-webid-profile-document\u2466"}],"title":"4. Overview"},{"refs":[{"id":"ref-for-webid-profile-document\u2467"},{"id":"ref-for-webid-profile-document\u2468"},{"id":"ref-for-webid-profile-document\u2460\u24ea"}],"title":"5.1.1. Contents of a WebID Profile Document"},{"refs":[{"id":"ref-for-webid-profile-document\u2460\u2460"},{"id":"ref-for-webid-profile-document\u2460\u2461"},{"id":"ref-for-webid-profile-document\u2460\u2462"}],"title":"5.5. Security Considerations"}],"url":"#webid-profile-document"},
};

document.addEventListener("DOMContentLoaded", ()=>{
    genAllDfnPanels();

    document.body.addEventListener("click", (e) => {
        // If not handled already, just hide all dfn panels.
        hideAllDfnPanels();
    });
});

window.addEventListener("resize", () => {
    // Pin any visible dfn panel
    queryAll(".dfn-panel.on, .dfn-panel.activated").forEach(el=>positionDfnPanel(el));
});

function genAllDfnPanels() {
    for(const panelData of Object.values(dfnPanelData)) {
        const dfnID = panelData.dfnID;
        const dfn = document.getElementById(dfnID);
        if(!dfn) {
            console.log(`Can't find dfn#${dfnID}.`, panelData);
            continue;
        }
        dfn.panelData = panelData;
        insertDfnPopupAction(dfn);
    }
}

function genDfnPanel(dfn, { dfnID, url, dfnText, refSections, external }) {
    const dfnPanel = mk.aside({
        class: "dfn-panel on",
        id: `infopanel-for-${dfnID}`,
        "data-for": dfnID,
        "aria-labelled-by":`infopaneltitle-for-${dfnID}`,
        },
        mk.span({id:`infopaneltitle-for-${dfnID}`, style:"display:none"},
            `Info about the '${dfnText}' ${external?"external":""} reference.`),
        mk.a({href:url, class:"dfn-link"}, url),
        refSections.length == 0 ? [] :
            mk.b({}, "Referenced in:"),
            mk.ul({},
                ...refSections.map(section=>
                    mk.li({},
                        ...section.refs.map((ref, refI)=>
                            [
                                mk.a({ href: `#${ref.id}` },
                                    (refI == 0) ? section.title : `(${refI + 1})`
                                ),
                                " ",
                            ]
                        ),
                    ),
                ),
            ),
        genLinkingSyntaxes(dfn),
    );

    dfnPanel.addEventListener('click', (event) => {
        if (event.target.nodeName == 'A') {
            scrollToTargetAndHighlight(event);
            pinDfnPanel(dfnPanel);
        }
        event.stopPropagation();
        refocusOnTarget(event);
    });
    dfnPanel.addEventListener('keydown', (event) => {
        if(event.keyCode == 27) { // Escape key
            hideDfnPanel({dfnPanel});
            event.stopPropagation();
            event.preventDefault();
        }
    });

    dfnPanel.dfn = dfn;
    dfn.dfnPanel = dfnPanel;
    return dfnPanel;
}



function hideAllDfnPanels() {
    // Delete the currently-active dfn panel.
    queryAll(".dfn-panel").forEach(dfnPanel=>hideDfnPanel({dfnPanel}));
}

function showDfnPanel(dfn) {
    hideAllDfnPanels(); // Only display one at a time.

    dfn.setAttribute("aria-expanded", "true");

    const dfnPanel = genDfnPanel(dfn, dfn.panelData);

    // Give the dfn a unique tabindex, and then
    // give all the tabbable panel bits successive indexes.
    let tabIndex = 100;
    dfn.tabIndex = tabIndex++;
    const tabbable = dfnPanel.querySelectorAll(":is(a, button)");
    for (const el of tabbable) {
        el.tabIndex = tabIndex++;
    }

    append(document.body, dfnPanel);
    positionDfnPanel(dfnPanel);
}

function positionDfnPanel(dfnPanel) {
    const dfn = dfnPanel.dfn;
    const dfnPos = getBounds(dfn);
    dfnPanel.style.top = dfnPos.bottom + "px";
    dfnPanel.style.left = dfnPos.left + "px";

    const panelPos = dfnPanel.getBoundingClientRect();
    const panelMargin = 8;
    const maxRight = document.body.parentNode.clientWidth - panelMargin;
    if (panelPos.right > maxRight) {
        const overflowAmount = panelPos.right - maxRight;
        const newLeft = Math.max(panelMargin, dfnPos.left - overflowAmount);
        dfnPanel.style.left = newLeft + "px";
    }
}

function pinDfnPanel(dfnPanel) {
    // Switch it to "activated" state, which pins it.
    dfnPanel.classList.add("activated");
    dfnPanel.style.position = "fixed";
    dfnPanel.style.left = null;
    dfnPanel.style.top = null;
}

function hideDfnPanel({dfn, dfnPanel}) {
    if(!dfnPanel) dfnPanel = dfn.dfnPanel;
    if(!dfn) dfn = dfnPanel.dfn;
    dfn.dfnPanel = undefined;
    dfnPanel.dfn = undefined;
    dfn.setAttribute("aria-expanded", "false");
    dfn.tabIndex = undefined;
    dfnPanel.remove()
}

function toggleDfnPanel(dfn) {
    if(dfn.dfnPanel) {
        hideDfnPanel(dfn);
    } else {
        showDfnPanel(dfn);
    }
}

function insertDfnPopupAction(dfn) {
    dfn.setAttribute('role', 'button');
    dfn.setAttribute('aria-expanded', 'false')
    dfn.tabIndex = 0;
    dfn.classList.add('has-dfn-panel');
    dfn.addEventListener('click', (event) => {
        toggleDfnPanel(dfn);
        event.stopPropagation();
    });
    dfn.addEventListener('keypress', (event) => {
        const kc = event.keyCode;
        // 32->Space, 13->Enter
        if(kc == 32 || kc == 13) {
            toggleDfnPanel(dfn);
            event.stopPropagation();
            event.preventDefault();
        }
    });
}

function refocusOnTarget(event) {
    const target = event.target;
    setTimeout(() => {
        // Refocus on the event.target element.
        // This is needed after browser scrolls to the destination.
        target.focus();
    });
}

// TODO: shared util
// Returns the root-level absolute position {left and top} of element.
function getBounds(el, relativeTo=document.body) {
    const relativeRect = relativeTo.getBoundingClientRect();
    const elRect = el.getBoundingClientRect();
    const top = elRect.top - relativeRect.top;
    const left = elRect.left - relativeRect.left;
    return {
        top,
        left,
        bottom: top + elRect.height,
        right: left + elRect.width,
    }
}

function scrollToTargetAndHighlight(event) {
    let hash = event.target.hash;
    if (hash) {
        hash = decodeURIComponent(hash.substring(1));
        const dest = document.getElementById(hash);
        if (dest) {
            dest.classList.add('highlighted');
            setTimeout(() => dest.classList.remove('highlighted'), 1000);
        }
    }
}

// Functions, divided by link type, that wrap an autolink's
// contents with the appropriate outer syntax.
// Alternately, a string naming another type they format
// the same as.
function needsFor(type) {
    switch(type) {
        case "descriptor":
        case "value":
        case "element-attr":
        case "attr-value":
        case "element-state":
        case "method":
        case "constructor":
        case "argument":
        case "attribute":
        case "const":
        case "dict-member":
        case "event":
        case "enum-value":
        case "stringifier":
        case "serializer":
        case "iterator":
        case "maplike":
        case "setlike":
        case "state":
        case "mode":
        case "context":
        case "facet": return true;

        default: return false;
    }
}
function refusesFor(type) {
    switch(type) {
        case "property":
        case "element":
        case "interface":
        case "namespace":
        case "callback":
        case "dictionary":
        case "enum":
        case "exception":
        case "typedef":
        case "http-header":
        case "permission": return true;

        default: return false;
    }
}
function linkFormatterFromType(type) {
    switch(type) {
        case 'scheme':
        case 'permission':
        case 'dfn': return (text) => `[=${text}=]`;

        case 'abstract-op': return (text) => `[\$${text}\$]`;

        case 'function':
        case 'at-rule':
        case 'selector':
        case 'value': return (text) => `''${text}''`;

        case 'http-header': return (text) => `[:${text}:]`;

        case 'interface':
        case 'constructor':
        case 'method':
        case 'argument':
        case 'attribute':
        case 'callback':
        case 'dictionary':
        case 'dict-member':
        case 'enum':
        case 'enum-value':
        case 'exception':
        case 'const':
        case 'typedef':
        case 'stringifier':
        case 'serializer':
        case 'iterator':
        case 'maplike':
        case 'setlike':
        case 'extended-attribute':
        case 'event':
        case 'idl': return (text) => `{{${text}}}`;

        case 'element-state':
        case 'element-attr':
        case 'attr-value':
        case 'element': return (element) => `<{${element}}>`;

        case 'grammar': return (text) => `${text} (within a <pre class=prod>)`;

        case 'type': return (text)=> `<<${text}>>`;

        case 'descriptor':
        case 'property': return (text) => `'${text}'`;

        default: return;
    };
};

function genLinkingSyntaxes(dfn) {
    if(dfn.tagName != "DFN") return;

    const type = dfn.getAttribute('data-dfn-type');
    if(!type) {
        console.log(`<dfn> doesn't have a data-dfn-type:`, dfn);
        return [];
    }

    // Return a function that wraps link text based on the type
    const linkFormatter = linkFormatterFromType(type);
    if(!linkFormatter) {
        console.log(`<dfn> has an unknown data-dfn-type:`, dfn);
        return [];
    }

    let ltAlts;
    if(dfn.hasAttribute('data-lt')) {
        ltAlts = dfn.getAttribute('data-lt')
            .split("|")
            .map(x=>x.trim());
    } else {
        ltAlts = [dfn.textContent.trim()];
    }
    if(type == "type") {
        // lt of "<foo>", but "foo" is the interior;
        // <<foo/bar>> is how you write it with a for,
        // not <foo/<bar>> or whatever.
        for(var i = 0; i < ltAlts.length; i++) {
            const lt = ltAlts[i];
            const match = /<(.*)>/.exec(lt);
            if(match) { ltAlts[i] = match[1]; }
        }
    }

    let forAlts;
    if(dfn.hasAttribute('data-dfn-for')) {
        forAlts = dfn.getAttribute('data-dfn-for')
            .split(",")
            .map(x=>x.trim());
    } else {
        forAlts = [''];
    }

    let linkingSyntaxes = [];
    if(!needsFor(type)) {
        for(const lt of ltAlts) {
            linkingSyntaxes.push(linkFormatter(lt));
        }
    }
    if(!refusesFor(type)) {
        for(const f of forAlts) {
            linkingSyntaxes.push(linkFormatter(`${f}/${ltAlts[0]}`))
        }
    }
    return [
        mk.b({}, 'Possible linking syntaxes:'),
        mk.ul({},
            ...linkingSyntaxes.map(link => {
                const copyLink = async () =>
                    await navigator.clipboard.writeText(link);
                return mk.li({},
                    mk.div({ class: 'link-item' },
                        mk.button({
                            class: 'copy-icon', title: 'Copy',
                            type: 'button',
                            _onclick: copyLink,
                            tabindex: 0,
                        }, mk.span({ class: 'icon' }) ),
                        mk.span({}, link)
                    )
                );
            })
        )
    ];
}
}
</script>
<script>/* Boilerplate: script-ref-hints */
"use strict";
{
let refsData = {
"#requesting-agent": {"export":true,"for_":[],"level":"1","normative":true,"shortname":"webid","spec":"webid-1","status":"local","text":"requesting agent","type":"dfn","url":"#requesting-agent"},
"#service": {"export":true,"for_":[],"level":"1","normative":true,"shortname":"webid","spec":"webid-1","status":"local","text":"service","type":"dfn","url":"#service"},
"#webid": {"export":true,"for_":[],"level":"1","normative":true,"shortname":"webid","spec":"webid-1","status":"local","text":"webid","type":"dfn","url":"#webid"},
"#webid-profile-document": {"export":true,"for_":[],"level":"1","normative":true,"shortname":"webid","spec":"webid-1","status":"local","text":"webid profile document","type":"dfn","url":"#webid-profile-document"},
};

function mkRefHint(link, ref) {
    const linkText = link.textContent;
    let dfnTextElements = '';
    if (ref.text != linkText) {
        dfnTextElements =
            mk.li({},
                mk.b({}, "Term: "),
                mk.span({}, ref.text)
            );
    }
    const forList = ref.for_;
    let forListElements;
    if(forList.length == 0) {
        forListElements = [];
    } else if(forList.length == 1) {
        forListElements = mk.li({},
            mk.b({}, "For: "),
            mk.span({}, forList[0]),
        );
    } else {
        forListElements = mk.li({},
            mk.b({}, "For: "),
            mk.ul({},
                ...forList.map(forItem =>
                    mk.li({},
                        mk.span({}, forItem)
                    ),
                ),
            ),
        );
    }
    const url = ref.url;
    const safeUrl = encodeURIComponent(url);
    const hintPanel = mk.aside({
        class: "ref-hint",
        id: `ref-hint-for-${safeUrl}`,
        "data-for": url,
        "aria-labelled-by": `ref-hint-for-${safeUrl}`,
    },
        mk.ul({},
            dfnTextElements,
            mk.li({},
                mk.b({}, "URL: "),
                mk.a({ href: url, class: "ref" }, url),
            ),
            mk.li({},
                mk.b({}, "Type: "),
                mk.span({}, `${ref.type}`),
            ),
            mk.li({},
                mk.b({}, "Spec: "),
                mk.span({}, `${ref.spec ? ref.spec : ''}`),
            ),
            forListElements
        ),
    );
    hintPanel.forLink = link;
    setupRefHintEventListeners(link, hintPanel);
    return hintPanel;
}

function hideAllRefHints() {
    queryAll(".ref-hint").forEach(el=>hideRefHint(el));
}

function hideRefHint(refHint) {
    const link = refHint.forLink;
    link.setAttribute("aria-expanded", "false");
    if(refHint.teardownEventListeners) {
        refHint.teardownEventListeners();
    }
    refHint.remove();
}

function showRefHint(link) {
    if(link.classList.contains("dfn-link")) return;
    const url = link.getAttribute("href");
    const ref = refsData[url];
    if(!ref) return;

    hideAllRefHints(); // Only display one at this time.

    const refHint = mkRefHint(link, ref);
    append(document.body, refHint);
    link.setAttribute("aria-expanded", "true");
    positionRefHint(refHint);
}

function setupRefHintEventListeners(link, refHint) {
    if (refHint.teardownEventListeners) return;
    // Add event handlers to hide the refHint after the user moves away
    // from both the link and refHint, if not hovering either within one second.
    let timeout = null;
    const startHidingRefHint = (event) => {
        if (timeout) {
            clearTimeout(timeout);
        }
        timeout = setTimeout(() => {
            hideRefHint(refHint);
        }, 1000);
    }
    const resetHidingRefHint = (event) => {
        if (timeout) clearTimeout(timeout);
        timeout = null;
    };
    link.addEventListener("mouseleave", startHidingRefHint);
    link.addEventListener("mouseenter", resetHidingRefHint);
    link.addEventListener("blur", startHidingRefHint);
    link.addEventListener("focus", resetHidingRefHint);
    refHint.addEventListener("mouseleave", startHidingRefHint);
    refHint.addEventListener("mouseenter", resetHidingRefHint);
    refHint.addEventListener("blur", startHidingRefHint);
    refHint.addEventListener("focus", resetHidingRefHint);

    refHint.teardownEventListeners = () => {
        // remove event listeners
        resetHidingRefHint();
        link.removeEventListener("mouseleave", startHidingRefHint);
        link.removeEventListener("mouseenter", resetHidingRefHint);
        link.removeEventListener("blur", startHidingRefHint);
        link.removeEventListener("focus", resetHidingRefHint);
        refHint.removeEventListener("mouseleave", startHidingRefHint);
        refHint.removeEventListener("mouseenter", resetHidingRefHint);
        refHint.removeEventListener("blur", startHidingRefHint);
        refHint.removeEventListener("focus", resetHidingRefHint);
    };
}

function positionRefHint(refHint) {
    const link = refHint.forLink;
    const linkPos = getBounds(link);
    refHint.style.top = linkPos.bottom + "px";
    refHint.style.left = linkPos.left + "px";

    const panelPos = refHint.getBoundingClientRect();
    const panelMargin = 8;
    const maxRight = document.body.parentNode.clientWidth - panelMargin;
    if (panelPos.right > maxRight) {
        const overflowAmount = panelPos.right - maxRight;
        const newLeft = Math.max(panelMargin, linkPos.left - overflowAmount);
        refHint.style.left = newLeft + "px";
    }
}

// TODO: shared util
// Returns the root-level absolute position {left and top} of element.
function getBounds(el, relativeTo=document.body) {
    const relativeRect = relativeTo.getBoundingClientRect();
    const elRect = el.getBoundingClientRect();
    const top = elRect.top - relativeRect.top;
    const left = elRect.left - relativeRect.left;
    return {
        top,
        left,
        bottom: top + elRect.height,
        right: left + elRect.width,
    }
}

function showRefHintListener(e) {
    // If the target isn't in a link (or is a link),
    // just ignore it.
    let link = e.target.closest("a");
    if(!link) return;

    // If the target is in a ref-hint panel
    // (aka a link in the already-open one),
    // also just ignore it.
    if(link.closest(".ref-hint")) return;

    // Otherwise, show the panel for the link.
    showRefHint(link);
}

function hideAllHintsListener(e) {
    // If the click is inside a ref-hint panel, ignore it.
    if(e.target.closest(".ref-hint")) return;
    // Otherwise, close all the current panels.
    hideAllRefHints();
}

document.addEventListener("DOMContentLoaded", () => {
    document.body.addEventListener("mousedown", showRefHintListener);
    document.body.addEventListener("focus", showRefHintListener);

    document.body.addEventListener("click", hideAllHintsListener);
});

window.addEventListener("resize", () => {
    // Hide any open ref hint.
    hideAllRefHints();
});
}
</script>